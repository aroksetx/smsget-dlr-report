import pika
import json
import sys
import pickle
from datetime import datetime
import smpplib.client
import smpplib.consts

# Configuration
RABBITMQ_HOST = '52.57.134.177'
RABBITMQ_PORT = 5672
RABBITMQ_USER = 'guest'
RABBITMQ_PASS = 'guest'
QUEUE_NAME = 'submit.sm.dummy_smpp'

# SMPP Configuration
JASMIN_SMPP_HOST = '52.57.134.177'
JASMIN_SMPP_PORT = 2775
SMPP_SYSTEM_ID = 'fulluser'
SMPP_PASSWORD = 'xrQrb9iP'


# SMPP DLR Status codes
class DLRStatus:
    DELIVERED = 'DELIVRD'
    EXPIRED = 'EXPIRED'
    DELETED = 'DELETED'
    UNDELIVERABLE = 'UNDELIV'
    ACCEPTED = 'ACCEPTD'
    UNKNOWN = 'UNKNOWN'
    REJECTED = 'REJECTD'


# SMPP Error codes
class SMPPError:
    NO_ERROR = 0
    INVALID_DEST = 1
    INVALID_SOURCE = 2
    SYSTEM_ERROR = 255


class MessageConsumer:
    def __init__(self, default_dlr_status=DLRStatus.DELIVERED, default_error_code=SMPPError.NO_ERROR):
        self.message_counter = 0
        self.connection = None
        self.channel = None
        self.default_dlr_status = default_dlr_status
        self.default_error_code = default_error_code
        self.smpp_client = None

    def deep_extract_value(self, obj, key_names):
        """Recursively search for values in nested objects"""
        if obj is None:
            return None

        # Direct attribute access
        if hasattr(obj, '__dict__'):
            for key in key_names:
                if hasattr(obj, key):
                    value = getattr(obj, key)
                    if value:
                        return value

            # Search nested attributes
            for attr_name, attr_value in obj.__dict__.items():
                result = self.deep_extract_value(attr_value, key_names)
                if result:
                    return result

        # Dictionary access
        if isinstance(obj, dict):
            for key in key_names:
                if key in obj:
                    value = obj[key]
                    if value:
                        return value

            # Search nested dicts
            for dict_value in obj.values():
                result = self.deep_extract_value(dict_value, key_names)
                if result:
                    return result

        # List/tuple access
        if isinstance(obj, (list, tuple)):
            for item in obj:
                result = self.deep_extract_value(item, key_names)
                if result:
                    return result

        return None

    def parse_message(self, body):
        """Parse message from different formats with deep inspection"""
        message_data = {
            'id': None,
            'from': None,
            'to': None,
            'content': None,
            'raw': None,
            'debug_info': []
        }

        # Try pickle first (Jasmin format)
        try:
            data = pickle.loads(body)
            message_data['raw'] = data
            message_data['debug_info'].append(f"Unpickled type: {type(data)}")
            message_data['debug_info'].append(f"Unpickled repr: {repr(data)}")

            # Show all attributes
            if hasattr(data, '__dict__'):
                message_data['debug_info'].append("Object attributes:")
                for key, value in data.__dict__.items():
                    message_data['debug_info'].append(f"  {key}: {value} (type: {type(value)})")

            # Try to extract message ID with multiple strategies
            id_fields = [
                'id', 'message_id', 'msgid', 'msg_id', 'messageId',
                'sequence', 'sequence_number', 'seqNum',
                'receipted_message_id', 'receipt_id',
                'sm_id', 'submit_sm_resp_id'
            ]

            # Deep search
            msg_id = self.deep_extract_value(data, id_fields)
            if msg_id:
                # Convert to string and clean
                if isinstance(msg_id, bytes):
                    msg_id = msg_id.decode('utf-8', errors='ignore')
                message_data['id'] = str(msg_id).strip()

            # Extract source/destination
            source_fields = ['source_addr', 'source', 'from', 'src', 'sender']
            dest_fields = ['destination_addr', 'destination', 'dest', 'to', 'recipient']

            source = self.deep_extract_value(data, source_fields)
            if source:
                if isinstance(source, bytes):
                    source = source.decode('utf-8', errors='ignore')
                message_data['from'] = str(source).strip()

            dest = self.deep_extract_value(data, dest_fields)
            if dest:
                if isinstance(dest, bytes):
                    dest = dest.decode('utf-8', errors='ignore')
                message_data['to'] = str(dest).strip()

            # Extract content
            content_fields = ['short_message', 'message', 'content', 'text', 'body', 'sm']
            content = self.deep_extract_value(data, content_fields)
            if content:
                if isinstance(content, bytes):
                    content = content.decode('utf-8', errors='ignore')
                message_data['content'] = str(content)

            # If still no ID, try generating from sequence or timestamp
            if not message_data['id']:
                seq = self.deep_extract_value(data, ['sequence', 'seq', 'seqNum'])
                if seq:
                    message_data['id'] = f"msg_{seq}_{int(datetime.now().timestamp())}"
                    message_data['debug_info'].append(f"Generated ID from sequence: {message_data['id']}")

            return message_data, 'pickle'

        except Exception as e:
            message_data['debug_info'].append(f"Pickle error: {e}")

        # Try JSON
        try:
            text = body.decode('utf-8')
            data = json.loads(text)
            message_data['raw'] = data
            message_data['id'] = self.deep_extract_value(data, ['id', 'message_id', 'msgid'])
            message_data['from'] = data.get('from') or data.get('source')
            message_data['to'] = data.get('to') or data.get('destination')
            message_data['content'] = data.get('content') or data.get('message')
            return message_data, 'json'
        except:
            pass

        # Plain text
        try:
            text = body.decode('utf-8')
            message_data['raw'] = text
            message_data['content'] = text
            # Generate an ID from content hash
            message_data['id'] = f"txt_{hash(text)}_{int(datetime.now().timestamp())}"
            return message_data, 'text'
        except:
            pass

        # Binary - generate ID from hash
        message_data['raw'] = body
        message_data['id'] = f"bin_{hash(body)}_{int(datetime.now().timestamp())}"
        message_data['debug_info'].append(f"Binary data, generated ID: {message_data['id']}")
        message_data['debug_info'].append(f"Binary length: {len(body)} bytes")
        message_data['debug_info'].append(f"Binary hex (first 100): {body[:100].hex()}")

        return message_data, 'binary'

    def connect_smpp(self):
        """Connect to Jasmin SMPP server"""
        try:
            if self.smpp_client:
                return True

            print(f"   üîå Connecting to Jasmin SMPP at {JASMIN_SMPP_HOST}:{JASMIN_SMPP_PORT}...")

            self.smpp_client = smpplib.client.Client(
                JASMIN_SMPP_HOST,
                JASMIN_SMPP_PORT,
                timeout=30
            )
            self.smpp_client.connect()
            self.smpp_client.bind_transceiver(
                system_id=SMPP_SYSTEM_ID,
                password=SMPP_PASSWORD
            )

            print(f"   ‚úÖ Connected and bound as transceiver")
            return True

        except Exception as e:
            print(f"   ‚ùå SMPP connection error: {e}")
            self.smpp_client = None
            return False

    def send_delivery_receipt_smpp(self, msg_id, status, error_code, source, destination, content):
        """Send Delivery Receipt via SMPP DELIVER_SM PDU"""
        try:
            if not msg_id:
                print("   ‚ö†Ô∏è  Cannot send DLR: No message ID")
                return False

            # Ensure SMPP connection
            if not self.connect_smpp():
                return False

            # Generate timestamps
            submit_date = datetime.now().strftime('%y%m%d%H%M')
            done_date = datetime.now().strftime('%y%m%d%H%M')

            # Build DLR text
            dlr_text = (
                f"id:{msg_id} "
                f"sub:001 "
                f"dlvrd:001 "
                f"submit date:{submit_date} "
                f"done date:{done_date} "
                f"stat:{status} "
                f"err:{error_code:03d} "
                f"text:{(content[:20] if content else '')}"
            )

            print(f"\n   üì® Sending DELIVERY RECEIPT via SMPP:")
            print(f"      Message ID: {msg_id}")
            print(f"      Status: {status}")
            print(f"      Error Code: {error_code}")
            print(f"      From: {destination or 'N/A'}")
            print(f"      To: {source or 'N/A'}")
            print(f"      DLR Text: {dlr_text}")

            # Send DELIVER_SM with DLR
            pdu = self.smpp_client.send_message(
                source_addr_ton=smpplib.consts.SMPP_TON_INTL,
                source_addr_npi=smpplib.consts.SMPP_NPI_ISDN,
                source_addr=str(destination) if destination else "0000",
                dest_addr_ton=smpplib.consts.SMPP_TON_INTL,
                dest_addr_npi=smpplib.consts.SMPP_NPI_ISDN,
                destination_addr=str(source) if source else "0000",
                short_message=dlr_text.encode('utf-8'),
                data_coding=0,
                esm_class=0x04,  # SMSC Delivery Receipt
                registered_delivery=False
            )

            print(f"   ‚úÖ Delivery Receipt sent successfully!")
            return True

        except Exception as e:
            print(f"   ‚ùå Failed to send Delivery Receipt: {e}")
            import traceback
            traceback.print_exc()

            if self.smpp_client:
                try:
                    self.smpp_client.disconnect()
                except:
                    pass
            self.smpp_client = None

            return False

    def callback(self, ch, method, properties, body):
        """Process incoming message and generate DLR"""
        self.message_counter += 1

        try:
            # Parse message
            msg_data, msg_format = self.parse_message(body)

            # Display message
            print("\n" + "=" * 70)
            print(f"üì® MESSAGE #{self.message_counter} | {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            print("=" * 70)

            # Show debug info
            if msg_data['debug_info']:
                print("\n   üîç DEBUG INFO:")
                for info in msg_data['debug_info']:
                    print(f"      {info}")

            # Message details
            print(f"\n   üìã EXTRACTED DATA:")
            if msg_data['id']:
                print(f"      üÜî MESSAGE ID: {msg_data['id']}")
            else:
                print(f"      ‚ö†Ô∏è  MESSAGE ID: Not found")

            if msg_data['from']:
                print(f"      üì§ FROM: {msg_data['from']}")
            if msg_data['to']:
                print(f"      üì• TO: {msg_data['to']}")
            if msg_data['content']:
                print(f"      üí¨ CONTENT: {msg_data['content'][:50]}...")

            print(f"\n   üìã METADATA:")
            print(f"      Format: {msg_format}")
            print(f"      Delivery Tag: {method.delivery_tag}")

            # Generate and send Delivery Receipt
            print(f"\n   üì¨ GENERATING DELIVERY RECEIPT:")

            dlr_sent = self.send_delivery_receipt_smpp(
                msg_id=msg_data['id'],
                status=self.default_dlr_status,
                error_code=self.default_error_code,
                source=msg_data['from'],
                destination=msg_data['to'],
                content=msg_data['content']
            )

            if dlr_sent:
                print(f"   ‚úÖ Delivery Receipt sent successfully")
            else:
                print(f"   ‚ö†Ô∏è  Failed to send Delivery Receipt")

            print("=" * 70)

            # Acknowledge and remove
            ch.basic_ack(delivery_tag=method.delivery_tag)
            print("‚úÖ Message processed and removed from queue\n")

        except Exception as e:
            print(f"\n‚ùå Error processing message: {e}")
            import traceback
            traceback.print_exc()
            ch.basic_nack(delivery_tag=method.delivery_tag, requeue=False)
            print("‚ùå Message rejected and removed\n")

    def start(self):
        """Start consuming messages"""
        try:
            credentials = pika.PlainCredentials(RABBITMQ_USER, RABBITMQ_PASS)
            parameters = pika.ConnectionParameters(
                host=RABBITMQ_HOST,
                port=RABBITMQ_PORT,
                credentials=credentials,
                heartbeat=600,
                blocked_connection_timeout=300
            )

            print("=" * 70)
            print("üê∞ RabbitMQ Consumer ‚Üí SMPP Delivery Receipt Generator")
            print("=" * 70)
            print(f"üîå Connecting to RabbitMQ at {RABBITMQ_HOST}:{RABBITMQ_PORT}...")

            self.connection = pika.BlockingConnection(parameters)
            self.channel = self.connection.channel()

            try:
                result = self.channel.queue_declare(queue=QUEUE_NAME, passive=True)
                message_count = result.method.message_count

                print(f"‚úÖ Connected to RabbitMQ successfully!")
                print(f"üì¨ Queue: {QUEUE_NAME}")
                print(f"üìä Messages waiting: {message_count}")
                print(f"üì® DLR Status: {self.default_dlr_status}")
                print(f"üî¢ Error Code: {self.default_error_code}")
                print("\nüëÇ Listening for messages... (Press Ctrl+C to stop)\n")

            except pika.exceptions.ChannelClosedByBroker:
                print(f"‚ùå Queue '{QUEUE_NAME}' does not exist!")
                sys.exit(1)

            self.channel.basic_qos(prefetch_count=1)
            self.channel.basic_consume(
                queue=QUEUE_NAME,
                on_message_callback=self.callback,
                auto_ack=False
            )

            self.channel.start_consuming()

        except KeyboardInterrupt:
            print("\n\n" + "=" * 70)
            print(f"üëã Stopping consumer... Processed {self.message_counter} messages")
            print("=" * 70)
            self.stop()
            sys.exit(0)

        except Exception as e:
            print(f"\n‚ùå Fatal error: {e}")
            import traceback
            traceback.print_exc()
            self.stop()
            sys.exit(1)

    def stop(self):
        """Stop and cleanup"""
        if self.smpp_client:
            try:
                self.smpp_client.unbind()
                self.smpp_client.disconnect()
                print("‚úÖ Disconnected from Jasmin SMPP")
            except:
                pass

        if self.connection and not self.connection.is_closed:
            self.connection.close()
            print("‚úÖ Disconnected from RabbitMQ")


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='RabbitMQ Consumer with SMPP Delivery Receipt')
    parser.add_argument('--dlr-status', choices=['DELIVRD', 'REJECTD', 'UNDELIV', 'EXPIRED', 'ACCEPTD'],
                        default='DELIVRD', help='DLR status (default: DELIVRD)')
    parser.add_argument('--error-code', type=int, default=0, help='Error code (default: 0)')

    args = parser.parse_args()

    status_map = {
        'DELIVRD': DLRStatus.DELIVERED,
        'REJECTD': DLRStatus.REJECTED,
        'UNDELIV': DLRStatus.UNDELIVERABLE,
        'EXPIRED': DLRStatus.EXPIRED,
        'ACCEPTD': DLRStatus.ACCEPTED
    }

    consumer = MessageConsumer(
        default_dlr_status=status_map[args.dlr_status],
        default_error_code=args.error_code
    )
    consumer.start()